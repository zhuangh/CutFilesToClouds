// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <stdio.h>
#include <errno.h>
#include <iostream>
#include <algorithm>
#include "KeyValueStore.h"
#include <transport/TSocket.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

// JSON header
#include "rapidjson/document.h"
#include "rapidjson/stringbuffer.h"
#include "rapidjson/prettywriter.h"
#include "rapidjson/filestream.h"

#include <boost/tokenizer.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/unordered_map.hpp>
#include <boost/foreach.hpp>

using namespace apache::thrift;
using namespace apache::thrift::protocol;
using namespace apache::thrift::transport;
using namespace apache::thrift::server;
/*
using boost::shared_ptr;
using boost::lexical_cast;
using boost::unordered_map;
*/
using namespace std;
using namespace boost;
using namespace KeyValueStore;
using namespace rapidjson;

//typedef boost::unordered_map<std::string, std::string> map;
typedef unordered_map<string, string> S2SMap;
typedef unordered_map<string, bool> hashList;
typedef unordered_map<string, hashList> listMap;
typedef map<int, pair<string, int> > serverMap;
//typedef map<string, bool> serverMap;
typedef std::vector<int> serverList;
typedef unordered_map<int, bool> I2BMap;
//typedef unordered_map<int, int> I2IMap;

//enum ServerStatus { OK, NOT_JOIN, DIED };

bool isPrefix(string const& s1, string const&s2)
{
    const char*p = s1.c_str();
    const char*q = s2.c_str();
    while (*p&&*q)
        if (*p++!=*q++)
            return false;
    return true;
}

vector<string> stringSeperate(string s){
  vector<string> v;
  char_separator<char> sep("_");
  tokenizer< char_separator<char> > tokens(s, sep);
  BOOST_FOREACH(const string& t, tokens) {
    v.push_back(t);
  }
  return v;
}

class KeyValueStoreHandler : virtual public KeyValueStoreIf {
 public:
  KeyValueStoreHandler(int argc, char** argv) {

    _timestamp = 0;
    
    _id = atoi(argv[1]);
    cout << "==== Server " << _id << " start ====" << endl;
    
    // Setup backend servers
    int servers = (argc-1)/2;
    for (int i=0 ; i<servers ; i++)
      _vectorClock.push_back(0);

    int index = ( _id == 0 ? 1 : 0);
    for(int i = 0; i < servers-1; i++) {

      if (_id == index) index++;
      string peer_ip = argv[i*2+3];
      int peer_port = atoi(argv[i*2+4]);      
      _liveServers[index] = true;
      _backendServerMap[index++] = make_pair(peer_ip, peer_port);
    }

    cout << "Backend servers:" << endl;
    BOOST_FOREACH(serverMap::value_type k, _backendServerMap) {
      pair<string, int> s = k.second;
      cout << k.first << " " << s.first << ":" << s.second << endl;
    }

    
    // Initiate data from other live server
    cout << "Initiating..." << endl;
    GetListResponse rp, rp2;
    Document document;

    cout << "Get K-V pair from other servers" << endl;
    BOOST_FOREACH(serverMap::value_type k, _backendServerMap) {
      try {
        rp = RemoteGetList("ALLVALUES", k.second);
      }
      catch (TException &tx) {
        cout << "Server " << k.first << " offline" << endl;
      }
      if (rp.status == KVStoreStatus::OK){
        cout << "Server " << k.first << " online" << endl;
        break;
      }
    }

    if (rp.status == KVStoreStatus::OK){
      for (size_t i=0 ; i<rp.values.size() ; i++){
        //cout << rp.values[i] << endl;
        string parse_string = rp.values[i];
        const char *c1 = parse_string.c_str();
        if (document.Parse<0>(c1).HasParseError()){
          printf("Parse Error!\n");
          return;
        }
        string key = document["key"].GetString();
        string value = document["value"].GetString();
        //cout << "Add " << key << " -> " << value << endl;
        _storage[key] = value;
      }
    }

    cout << "Get Lists from other servers" << endl;
    BOOST_FOREACH(serverMap::value_type k, _backendServerMap) {
      try {
        rp2 = RemoteGetList("ALLLISTS", k.second);
      }
      catch (TException &tx) {
        cout << "Server " << k.first << " offline" << endl;    
      }
      if (rp2.status == KVStoreStatus::OK){
        cout << "Server " << k.first << " online" << endl;
        break;
      }
    }
    if (rp2.status == KVStoreStatus::OK){
      for (size_t i=0 ; i<rp2.values.size() ; i++){
        //cout << rp2.values[i] << endl;
        string parse_string = rp2.values[i];
        const char *c1 = parse_string.c_str();
        if (document.Parse<0>(c1).HasParseError()){
          printf("Parse Error!\n");
          return;
        }
        string key = document["key"].GetString();
        const Value& array = document["list"];
        hashList h;
        for (size_t i=0 ; i< array.Size() ; i++){
          const Value& item = array[i];
          h[item.GetString()] = true;
          //cout << "list[" << key << "] - " << item.GetString() << endl;
        }
        _list[key] = h;

      }
    }
    
    cout << "========================" << endl;

  }

  void Get(GetResponse& _return, const std::string& key) {
    // Your implementation goes here
    cout << "Get K: " << key << endl;

    if (key == "LIVE_CHECK"){
      _return.value = "YES";
      _return.status = KVStoreStatus::OK;
      return;
    }
    else if(key == "TIME"){
      _vectorClock[_id]++;
      _return.value = GetClockString();
      _return.status = KVStoreStatus::OK;
      return;
    } 

    if (_storage.find(key) == _storage.end()){
      // Key not found
      _return.status = KVStoreStatus::EKEYNOTFOUND;
    }
    else {
      // Key found
      _return.value = _storage[key];
      _return.status = KVStoreStatus::OK;
    }
  }

  void GetList(GetListResponse& _return, const std::string& key) {
    // Your implementation goes here
    cout << "GetList K: " << key << endl;

    // Special KEY request for initialize new servers
    if (key == "ALLVALUES"){
      BOOST_FOREACH(S2SMap::value_type k, _storage) {
        string key = k.first;
        string value = k.second;
        string json_string = string("{\"key\":\"") + key + string("\",\"value\":\"") 
                                         + value + string("\"}");
        _return.values.push_back(json_string);
      }
      _return.status =  KVStoreStatus::OK;
      return;
    }
    else if (key == "ALLLISTS"){
      BOOST_FOREACH(listMap::value_type k, _list) {
        string key = k.first;
        hashList values = k.second;
        Document d;
        d.SetObject();

        Value s;
        s.SetString(key.c_str());
        
        d.AddMember("key", s, d.GetAllocator());
        
        Value a(kArrayType);
        for (hashList::iterator it=values.begin() ; it!=values.end() ; it++){
          Value s2;
          s2.SetString((it->first).c_str());
          a.PushBack(s2, d.GetAllocator());
        }
        d.AddMember("list", a, d.GetAllocator());

        // Convert JSON document to string
        StringBuffer strbuf;
        Writer<StringBuffer> writer(strbuf);
        d.Accept(writer);
        _return.values.push_back(strbuf.GetString());
        
      }
      _return.status =  KVStoreStatus::OK;
      return;
    }


    listMap::iterator i = _list.find(key);
    //hashList myList;
    if(i == _list.end()){
      cout << "EKEYNOTFOUND" << endl;
      _return.status = KVStoreStatus::EKEYNOTFOUND;
      return;
    }
    else{
      cout << "KEY FOUND" << endl;
      hashList myList = i->second;
      BOOST_FOREACH(hashList::value_type k, myList) {
        _return.values.push_back(k.first);
      }
    }
    
    _return.status =  KVStoreStatus::OK;
  }

  KVStoreStatus::type Put(const std::string& key, const std::string& value, const std::string& clientid) {
    // Your implementation goes here
    string new_key(key);
    cout << "Put from " << clientid << " K: " << key << " V: " << value << endl;

    // 1. Generate trsation id: ${_id}_${timestamp}
    string tran_id = lexical_cast<string>(_id) + "_" + lexical_cast<string>(_vectorClock[_id]++);

    // 2. Log trsaction with the transaction id: ${_id}_${timestamp}
    _transactionLog[tran_id] = false;

    /*
    // 3. If the key is POST_, replace the client timestamp to vector clock
    vector<string> res = stringSeperate(key);
    if (res[0] == string("POST")){
      string clientTime = res[2];
      string clock_string = _clockTransform[clientid + string("_") + clientTime];
      new_key = string("POST_") + clock_string;
      _clockTransform.erase(clientid + string("_") + clientTime);
    }
    */

    // 4. Send to all backup servers
    BOOST_FOREACH(I2BMap::value_type k, _liveServers) {
      if (k.second == false) continue;
      pair<string, int> server = _backendServerMap[k.first];
      string modified_value = JsonMsgForBackups(tran_id, _id, value);
      RemoteKVPut(new_key, modified_value, server);
    }

    // 5. Write to local memory 
    _storage[new_key] = value;

    // 6. Log this trsaction has been done to prevent double writing
    _transactionLog[tran_id] = true;

    
    return KVStoreStatus::OK;
  }

  KVStoreStatus::type AddToList(const std::string& key, const std::string& value, const std::string& clientid) {
    // Your implementation goes here
    cout << "AddToList from " << clientid << " K: " << key << " V: " << value << endl;
    string new_value(value);
    // 1. Generate trsation id: ${_id}_${timestamp}
    string tran_id = lexical_cast<string>(_id) + "_" + lexical_cast<string>(_vectorClock[_id]++);
    
    /*
    // 2. If the key is PLIST_, replace the client timestamp to vector clock
    vector<string> res = stringSeperate(key);
    if (res[0] == string("PLIST")){
      cout << "Add new post" << endl;
      string clientTime = value;
      new_value = GetClockString();
      _clockTransform[clientid + string("_") + clientTime] = new_value;

      return KVStoreStatus::OK;
    }
    */

    // 3. Check this value has been already added
    listMap::iterator i = _list.find(key);
    hashList myList;
    if (i == _list.end()){
      // Key not found
    }
    else{
      // Key found
      myList = i->second;
      // The value has already been in the list
      if (myList.find(new_value) != myList.end()){
        return KVStoreStatus::EITEMEXISTS;
      }
    }
    
    // 4. Log trsaction with the transaction id: ${_id}_${timestamp}
    _transactionLog[tran_id] = false;

    // 5. Send to all backup servers
    BOOST_FOREACH(I2BMap::value_type k, _liveServers) {
      if (k.second == false) continue;
      pair<string, int> server = _backendServerMap[k.first];
      string modified_value = JsonMsgForBackups(tran_id, _id, new_value);
      RemoteKVAddToList(key, modified_value, server);
    }

    // 6. Write to local memory 
    myList[new_value] = true;
    _list[key] = myList;

    // 7. Log this trsaction has been done to prevent double writing
    _transactionLog[tran_id] = true;

    return KVStoreStatus::OK;
    
  }

  KVStoreStatus::type RemoveFromList(const std::string& key, const std::string& value, const std::string& clientid) {
    // Your implementation goes here
    cout << "RemoveFromList from " << clientid << " K: " << key << " V: " << value << endl;
    
    string new_value(value);
    // 1. Generate trsation id: ${_id}_${timestamp}
    string tran_id = lexical_cast<string>(_id) + "_" + lexical_cast<string>(_vectorClock[_id]++);
    
    /*
    // 2. If the key is PLIST_, replace the client timestamp to vector clock
    vector<string> res = stringSeperate(key);
    if (res[0] == string("PLIST")){
      cout << "Add new post" << endl;
      string clientTime = value;
      new_value = GetClockString();
      _clockTransform[clientid + string("_") + clientTime] = new_value;

      return KVStoreStatus::OK;
    }
    */

    // 3. Check this value has been already added
    listMap::iterator i = _list.find(key);
    hashList myList;
    if (i == _list.end()){
      // Key not found
      return KVStoreStatus::EKEYNOTFOUND;
    }
    else{
      // Key found
      myList = i->second;
      if (myList.find(value) == myList.end()){
        // No such value in the list
        return KVStoreStatus::EITEMNOTFOUND;
      }
      else{
        // Value found in the list
      }
    }
    
    // 4. Log trsaction with the transaction id: ${_id}_${timestamp}
    _transactionLog[tran_id] = false;

    // 5. Send to all backup servers
    BOOST_FOREACH(I2BMap::value_type k, _liveServers) {
      if (k.second == false) continue;
      pair<string, int> server = _backendServerMap[k.first];
      string modified_value = JsonMsgForBackups(tran_id, _id, new_value);
      RemoteKVRemoveFromList(key, modified_value, server);
    }

    // 6. Write to local memory
    myList.erase(value);
    _list[key] = myList;

    // 7. Log this trsaction has been done to prevent double writing
    _transactionLog[tran_id] = true;

    return KVStoreStatus::OK;

  }

  // Ascynchronous RPCs
  // One way Put
  void KVPut(const std::string& key, const std::string& value, const std::string& clientid){
    cout << "KVPut from " << clientid << " K: " << key << " V: " << value << endl;
    
    // 1. Parse JSON, get trsation id: ${clientid}_${timestamp}
    Document d;
    const char *c1 = value.c_str();
    if (d.Parse<0>(c1).HasParseError()){
      printf("Parse Error!\n");
      return;
    }
    string tran_id = d["tran_id"].GetString();
    string content = d["content"].GetString();
    int sender = d["sender"].GetInt();
    cout << "tran_id: " << tran_id << "sender: " << sender << endl;
    
    // Update vector clock
    const Value& newVectorClock = d["clock"];
    assert(newVectorClock.IsArray());
    for (size_t i = 0 ; i<newVectorClock.Size() ; i++){
      _vectorClock[i] = newVectorClock[i].GetInt();
    }
    _vectorClock[_id]++;

    // 2. Check whether this transaction has been executed or not
    if (_transactionLog[tran_id]) return;

    // 3. Log trsaction with the transaction id: ${clientid}_${timestamp}
    _transactionLog[tran_id] = false;

    // 4. Check the sender is live or not
    GetResponse rp = RemoteGet("LIVE_CHECK",_backendServerMap[sender]);

    // 5. If sender failed, send to all backup servers
    if (rp.status != KVStoreStatus::OK){
      // Remove sender from live serve list
      _liveServers.erase(sender);

      BOOST_FOREACH(I2BMap::value_type k, _liveServers) {
        if (k.second == false) continue;
        pair<string, int> server = _backendServerMap[k.first];
        string modified_value = JsonMsgForBackups(tran_id, _id, content);
        RemoteKVPut(key, modified_value, server);
      }
    }

    // 6. Write to local memory 
    _storage[key] = value;

    // 7. Log this trsaction has been done to prevent double writing
    _transactionLog[tran_id] = true;
    
  }

  // One way AddToList
  void KVAddToList(const std::string& key, const std::string& value, const std::string& clientid){
    cout << "KVAddToList from " << clientid << " K: " << key << " V: " << value << endl;

    // 1. Parse JSON, get trsation id: ${clientid}_${timestamp}
    Document d;
    const char *c1 = value.c_str();
    if (d.Parse<0>(c1).HasParseError()){
      printf("Parse Error!\n");
      return;
    }
    string tran_id = d["tran_id"].GetString();
    string content = d["content"].GetString();
    int sender = d["sender"].GetInt();
    cout << "tran_id: " << tran_id << " sender: " << sender << endl;
    
    // Update vector clock
    const Value& newVectorClock = d["clock"];
    assert(newVectorClock.IsArray());
    for (size_t i = 0 ; i<newVectorClock.Size() ; i++){
      _vectorClock[i] = newVectorClock[i].GetInt();
    }
    _vectorClock[_id]++;

    // 2. Check whether this transaction has been executed or not
    if (_transactionLog[tran_id]) return;

    // 3. Log trsaction with the transaction id: ${clientid}_${timestamp}
    _transactionLog[tran_id] = false;

    // 4. Check the sender is live or not
    GetResponse rp = RemoteGet("LIVE_CHECK",_backendServerMap[sender]);

    // 5. If sender failed, send to all backup servers
    if (rp.status != KVStoreStatus::OK){
      // Remove sender from live serve list
      _liveServers.erase(sender);

      BOOST_FOREACH(I2BMap::value_type k, _liveServers) {
        if (k.second == false) continue;
        pair<string, int> server = _backendServerMap[k.first];
        string modified_value = JsonMsgForBackups(tran_id, _id, content);
        RemoteKVAddToList(key, modified_value, server);
      }
    }

    // 6. Write to local memory 
    listMap::iterator i = _list.find(key);
    hashList myList;
    if (i == _list.end()){
      // Key not found
    }
    else{
      // Key found
      myList = i->second;
      // The value has already been in the list
      if (myList.find(value) != myList.end()){
        cout << "KVStoreStatus::EITEMEXISTS" << endl;
        return;
      }
    }
    myList[value] = true;
    _list[key] = myList;

    // 7. Log this trsaction has been done to prevent double writing
    _transactionLog[tran_id] = true;

  }

  // One way RemoveFromList
  void KVRemoveFromList(const std::string& key, const std::string& value, const std::string& clientid){
    cout << "KVRemoveFromList from " << clientid << " K: " << key << " V: " << value << endl;

    // 1. Parse JSON, get trsation id: ${clientid}_${timestamp}
    Document d;
    const char *c1 = value.c_str();
    if (d.Parse<0>(c1).HasParseError()){
      printf("Parse Error!\n");
      return;
    }
    string tran_id = d["tran_id"].GetString();
    string content = d["content"].GetString();
    int sender = d["sender"].GetInt();
    cout << "tran_id: " << tran_id << " sender: " << sender << endl;
    
    // Update vector clock
    const Value& newVectorClock = d["clock"];
    assert(newVectorClock.IsArray());
    for (size_t i = 0 ; i<newVectorClock.Size() ; i++){
      _vectorClock[i] = newVectorClock[i].GetInt();
    }
    _vectorClock[_id]++;

    // 2. Check whether this transaction has been executed or not
    if (_transactionLog[tran_id]) return;

    // 3. Log trsaction with the transaction id: ${clientid}_${timestamp}
    _transactionLog[tran_id] = false;

    // 4. Check the sender is live or not
    GetResponse rp = RemoteGet("LIVE_CHECK",_backendServerMap[sender]);

    // 5. If sender failed, send to all backup servers
    if (rp.status != KVStoreStatus::OK){
      // Remove sender from live serve list
      _liveServers.erase(sender);

      BOOST_FOREACH(I2BMap::value_type k, _liveServers) {
        if (k.second == false) continue;
        pair<string, int> server = _backendServerMap[k.first];
        string modified_value = JsonMsgForBackups(tran_id, _id, content);
        RemoteKVRemoveFromList(key, modified_value, server);
      }
    }

    // 6. Write to local memory 
    listMap::iterator i = _list.find(key);
    hashList myList;
    if (i == _list.end()){
      // Key not found
      return;
    }
    else{
      // Key found
      myList = i->second;
      if (myList.find(value) == myList.end()){
        // No such value in the list
        return;
      }
      else{
        // Value found in the list
        myList.erase(value);
        _list[key] = myList;
      }
    }

    // 7. Log this trsaction has been done to prevent double writing
    _transactionLog[tran_id] = true;

  }

  // Wrappers to call RPCs
  KeyValueStore::GetResponse RemoteGet(std::string key, pair<string,int> server) {
    KeyValueStore::GetResponse response;
    boost::shared_ptr<TSocket> socket(new TSocket(server.first, server.second));
    boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
    boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
    KeyValueStoreClient client(protocol);
    transport->open();
    client.Get(response, key);
    transport->close();
    return response;
  }

  KeyValueStore::GetListResponse RemoteGetList(std::string key, pair<string,int> server) {
    KeyValueStore::GetListResponse response;
    boost::shared_ptr<TSocket> socket(new TSocket(server.first, server.second));
    boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
    boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
    KeyValueStoreClient client(protocol);
    transport->open();
    client.GetList(response, key);
    transport->close();
    return response;
  }

  void RemoteKVPut(std::string key, std::string value, pair<string,int> server) {
    boost::shared_ptr<TSocket> socket(new TSocket(server.first, server.second));
    boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
    boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
    KeyValueStoreClient client(protocol);
    transport->open();
    string clientid = lexical_cast<string>(_id);
    client.KVPut(key, value, clientid);
    transport->close();
  }

  void RemoteKVAddToList(std::string key, std::string value, pair<string,int> server) {
    boost::shared_ptr<TSocket> socket(new TSocket(server.first, server.second));
    boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
    boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
    KeyValueStoreClient client(protocol);
    transport->open();
    string clientid = lexical_cast<string>(_id);
    client.KVAddToList(key, value, clientid);
    transport->close();
  } 

  void RemoteKVRemoveFromList(std::string key, std::string value, pair<string,int> server) {
    boost::shared_ptr<TSocket> socket(new TSocket(server.first, server.second));
    boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
    boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
    KeyValueStoreClient client(protocol);
    transport->open();
    string clientid = lexical_cast<string>(_id);
    client.KVRemoveFromList(key, value, clientid);
    transport->close();
  } 

  serverList GetLiveServers(){
    serverList output;
    BOOST_FOREACH(I2BMap::value_type k, _liveServers) {
      if (k.second) output.push_back(k.first);
    }
    return output;
  }

  string JsonMsgForBackups(string tran_id, int sender, string content){
    Document d;
    d.SetObject();
    Value t;
    {
      t.SetString(tran_id.c_str());
      d.AddMember("tran_id", t, d.GetAllocator());
    }
    Value s(sender);
      d.AddMember("sender", s, d.GetAllocator());
    Value c(kArrayType);
    {
      for (size_t i=0 ; i<_vectorClock.size() ; i++){
        c.PushBack(_vectorClock[i], d.GetAllocator());
      }
      d.AddMember("clock", c, d.GetAllocator());
    }
    Value b(kArrayType);
    {
      serverList sList = GetLiveServers();
      for (size_t i=0 ; i<sList.size() ; i++){
        b.PushBack(sList[i], d.GetAllocator());
      }
      d.AddMember("servers", b, d.GetAllocator());
    }
    Value v;
    {
      v.SetString(content.c_str());
      d.AddMember("content", v, d.GetAllocator());
    }
    // Convert JSON document to string
    StringBuffer strbuf;
    Writer<StringBuffer> writer(strbuf);
    d.Accept(writer);

    return strbuf.GetString();
  }

  string GetClockString(){
    string output;
    for (size_t i=0 ; i<_vectorClock.size() ; i++){
      if (i != 0) output += string("_");
      output += lexical_cast<string>(_vectorClock[i]);
    }
    return output;
  }

  private:
    int _id;
    //vector < pair<string, int> > _backendServerVector;
    
    serverMap _backendServerMap;

    S2SMap     _storage;
    listMap   _list;

    unordered_map<string, bool> _transactionLog;
    I2BMap _liveServers;
    S2SMap _clockTransform;

    int _timestamp;
    vector<int> _vectorClock;


};

int main(int argc, char **argv) {
  if((argc < 3) || !(argc % 2)) {
      cerr << "Usage: " << argv[0] << " id localport peer1 port1..." << endl;
      exit(1);
  }
  int port = atoi(argv[2]);
  shared_ptr<KeyValueStoreHandler> handler(new KeyValueStoreHandler(argc, argv));
  shared_ptr<TProcessor> processor(new KeyValueStoreProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

