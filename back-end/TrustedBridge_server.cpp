// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <transport/TSocket.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

#include "TrustedBridge.h"
#include "KeyValueStore.h"

#include "sha.h"
#include "hex.h"
#include "base64.h"
#include "files.h"

#include <boost/lexical_cast.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>
#include <boost/foreach.hpp>

#include <iostream>
#include <cstdlib>
#include <string>
#include <math.h>
#include <malloc.h>
#include <vector>
#include <sstream>
#include <time.h>
#include <fstream>

#include <pthread.h>
#include <queue>
#include <list>
#include <boost/thread/mutex.hpp>
#include <boost/thread/condition.hpp>
//#include <boost/thread/thread.hpp>
//#include <thread>

#include "FileAccess.h"

/* Add by Early */
#include <fstream>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;
using boost::thread;

using namespace std;
using namespace  ::TrustedBridge;
using namespace  ::KeyValueStore;

using boost::property_tree::ptree;
using boost::property_tree::read_json;
using boost::property_tree::write_json;

#define DEBUG

#define CONCURRENT_QUEUE
#ifdef CONCURRENT_QUEUE
template <typename Data>
class Concurrent_Queue{
private:
    queue<Data> _queue;
    mutable boost::mutex _mutex;
    boost::condition_variable _cvariable;
public:
    void enque(Data const& data){
        boost::mutex::scoped_lock lock(_mutex);
        _queue.push(data);
        lock.unlock();
        _cvariable.notify_one();    
    }

    bool empty() const{
        boost::mutex::scoped_lock lock(_mutex);
        return _queue.empty();    
    }

    bool try_deque(Data& dequed_value){
        boost::mutex::scoped_lock lock(_mutex);
        if (_queue.empty()){
            return false;
        }    
        dequed_value = _queue.front();
        _queue.pop();
        return true;
    }

    void wait_and_deque(Data& dequed_value){
        boost::mutex::scoped_lock lock(_mutex);
        while(_queue.empty())
            _cvariable.wait(lock);
        dequed_value = _queue.front();
        _queue.pop();    
    }

   
};
#endif

class TrustedBridgeHandler : virtual public TrustedBridgeIf {
 public:
  TrustedBridgeHandler(std::string storageServer, int storageServerPort) {

    _storageServer = storageServer;
    _storageServerPort = storageServerPort;
    _clientid = "0";

    //KVStoreInit();

    //AddToList("test_files","file1.avi", _clientid);  
    //AddToList("test_files","file2.txt", _clientid);
    //AddToList("test_files","file3.jpg", _clientid);
    // Your initialization goes here
    //string json = "{\"clouds\":[{\"id\":0,\"type\":\"dropbox\",\"token1\":\"ryfmsl9lqpkaz0u\",\"token2\":\"h8ahi6b9xfdr92e\"}]}";
    
    fa = new FileAccess(_storageServer, _storageServerPort); 

    
   // Put("test_clouds",json, _clientid);
   Put("test_key", "key", _clientid);

    struct thread_data{
        int thread_id; 
    };

    // create cousumer threads to upload segments
  }

  TrustedBridgeHandler() {
    // Your initialization goes here
  }

  TBStatus::type AddUser(const std::string& username){
     	cout << "AddUser " << username << endl;
        return TBStatus::NOT_IMPLEMENTED;
  }

  void GetFileList(TrustedBridge::GetListResponse& _return, const std::string& username) {
    // Your implementation goes here
    cout << "GetFileList for " << username << endl;
    KeyValueStore::GetListResponse listResponse = GetList(username + "_files");
    if (listResponse.status == KVStoreStatus::OK){
        _return.status = TBStatus::OK;
        _return.values.assign(listResponse.values.begin(), listResponse.values.end());
    } 
    else if (listResponse.status == KVStoreStatus::EKEYNOTFOUND){
        _return.status = TBStatus::EFILENOTFOUND;
       // return;    
    }
    else{
        _return.status = TBStatus::INTERNAL_FAILURE;
       // return;    
    }

   printf("GetFileList\n");
  }

  TBStatus::type Remove(const std::string& username, const std::string& filename) {
    // Your implementation goes here
    printf("Remove\n");
    return TBStatus::NOT_IMPLEMENTED; 

  }

  void DownloadFromExt(DownloadResponse& _return, const std::string& username, const std::string& filename) {
    // Your implementation goes here
    printf("DownloadFromExt\n");
  }

  void DownloadFromServer(DownloadResponse& _return, const std::string& username, const std::string& filename) {
    // Your implementation goes here
#define TIMER
#ifdef TIMER
     time_t start = time(0);
#endif
    cout << username << " want download the file " << filename;
    string key = username + "_" + filename;
    GetResponse response = Get(key);
    string value = response.value;
   
    std::stringstream ss;
    ss << value;  
    cout << " get the segment values " << value << endl;
     
    ptree pt;
    read_json(ss, pt);
    
    string parentNode = username + "_" + filename;
    cout << "parentNode " + parentNode << endl;
    
    std::list<string> l;

    int index = 1;
    BOOST_FOREACH(ptree::value_type& v, pt.get_child("array")){
        
        string counter = boost::lexical_cast<string>(index++);
        string segmentName = v.second.get_child(counter).data();
        cout << segmentName << endl;
   
        std::string key = username + "_" + segmentName;
        GetResponse response = Get(key);
        cout << key << "'s value is " << response.value << endl;
        int extid = boost::lexical_cast<int>(response.value);

        cout << "Download " << segmentName << " from " << extid << " for user " <<  username << endl;
        //FileAccess fa(_storageServer, _storageServerPort);
        fa->Download(username, segmentName, extid);
    
        l.push_back(segmentName);    
    }


    // ofstream retFile;
    string path = "/classes/cse223b/sp13/eshen/cse-223b-projcet/front-end/download_temp/" + filename; 
    // retFile.open(path.c_str(), ios::binary | ios::app);
    FILE * retFile ;
    retFile = fopen( path.c_str(), "ab" ) ;


    for (list<string>::iterator it = l.begin(); it != l.end(); ++it){
        cout << *it << endl;
        string path = "./download/";    
        string f = path + *it;
        void* data;
        int size = 0;
        
        // ifstream file_to_merge;
        // file_to_merge.open(f.c_str(), ios::binary);
        FILE * file_to_merge;
        file_to_merge = fopen(f.c_str(),"rb");

       // if (file_to_merge.is_open()){
        if( file_to_merge > 0){
            cout << "Read file " << f << endl;
            // file_to_merge.seekg(0, ios::end);
            /*          
                        size = file_to_merge.tellg();
                        fseek(file_to_merge, 

                        file_to_merge.read(data, size);
                        file_to_merge.close();
             */
            fseek(file_to_merge, 0L, SEEK_END);
            size = ftell(file_to_merge);
            fseek(file_to_merge, 0L, SEEK_SET);
            data = malloc(size);
            int fp = fread(data, 1 , size , file_to_merge); 
            fwrite(data , 1, fp , retFile);
            cout << "Packing file " << size << endl;
            // retFile.write(data, size);
            free(data);
  //          break;
        }else{
            cout << "Could not open file" << f << endl;    
        }
        fclose(file_to_merge);
    }
    
    fclose(retFile);
    printf("Done DownloadFromServer\n");
  
#ifdef TIMER
    time_t end = time(0);
   // double diffticks = b - a;
   // double diffms = (diffticks)/(CLOCKS_PER_SEC);
    double diffms = difftime(start, end) ; 
    cout << "Download Cost " << diffms << " second(s)";
    cout << start << " " << end << " " << diffms << " " << diffms * 1000.0 << endl;
#endif
 }

  TBStatus::type UploadToExt(const std::string& filename, const std::string& username, const std::string& file) {
    cout << "UploadToExt" << endl;
    return TBStatus::NOT_IMPLEMENTED; 
  }

  void *checkUploadQueue(void* context){
        //int id = *(int*)thread;
        //struct thread_data *my_data;
        //my_data = (struct thread_data*) t_data;
  #ifdef DEBUG    
       cout << "Thread is checking" << endl;
  #endif     
       while(true){
  #ifdef DEBUG
            cout << " checking queue" << endl;
  #endif         
            if (!uploadQueue.empty()){               
                string ret;
                uploadQueue.try_deque(ret);
  #ifdef DEBUG
                cout << "Deque " << ret << endl;
  #endif          
            }
       }
  }

  void pushToUploadQueue(string data){
       
       cout << "Enque" << endl;
       uploadQueue.enque(data);    
  }

  TBStatus::type UploadToServer(const std::string& username, const std::string& filename, const std::string& file) {
    /* @Early
     * This code segment is just for testing, not real UploadToServer(). The input file 
     * from client browser will be collected by PHP serverlet. The PHP program will 
     * serialize the file into binary string, and call UploadToServer() RPC. The RPC
     * receiver here in C++ will get a std::string which contains the binary string.
     * Then we could use std::ofstream to write to the local disk on sysnet.
     */
#ifdef TIMER
     time_t start = time(0);
#endif
    cout << "UploadToServer" << endl;
    cout << "File: " << filename << endl;
    cout << "User: " << username << endl;

    ofstream fileStream;
    string path = "/classes/cse223b/sp13/eshen/cse-223b-projcet/front-end/upload_temp/"+filename;
    /*
    fileStream.open(path.c_str(), ios::out | ios::binary);
    fileStream.write(file.c_str(), file.size());
    fileStream.close();
    */
    cout << "File saved to local" << endl;

    AddToList(username+"_files",filename, "0");
    /* @Early end */
   
    //Add <$username_$filename, filename> to kv server
    //string key = username + "_" + filename;
    //string value = filename;
    //AddToList(key, value, "0");

    //Get key for current user;
    string key = username + "_key";
    KeyValueStore::GetResponse response = Get(key);
    string userKey = response.value;
    vector<int> chunk_size;
    getPartitionOffsets(chunk_size, userKey);
    split_func(path, filename, chunk_size, username);
    // printf("UploadToExt\n");

#ifdef TIMER
    time_t end = time(0);
   // double diffticks = b - a;
   // double diffms = (diffticks)/(CLOCKS_PER_SEC);
    double diffms = difftime(start, end) ; 
    cout << "Upload Cost " << diffms << " second(s)";
    cout << start << " " << end << " " << diffms << " " << diffms * 1000.0 << endl;
#endif
    printf("UploadToServer\n");
    return TBStatus::OK; 
 
  }


  int getExtSize(std::string username){
      
    GetResponse response;
    response = Get(username + "_clouds");
   
    std::stringstream ss;
    ss << response.value;
    
    cout << "getExtSize " << response.value << endl;
     
    ptree pt;
    read_json(ss, pt);
    int size = pt.get_child("clouds").size();
    cout << username << " has " << size << "clouds" << endl;
    return size;
  }

  /*
   * @Hao Zhuang
   */
//  int merge_file()

  /*
   * @Hao Zhuang
   */
  int split_func( string filename, string ori_filename, vector<int> chunk_size, const std::string& username){

    string splitfn;
    long part = 0;
    FILE *fp, *op;
    //void *fb;
    string ofn;
    ofn = filename;

    int sz = 0;
#define OPEN_C
#ifdef OPEN_C
    //filename = "/classes/cse223b/sp13/eshen/cse-223b-projcet/front-end/upload_temp/project3.pdf";
    //filename = "./TrustedBridge_server.cpp.jin";
   
    fp = fopen(filename.c_str(), "rb");
    if (fp == NULL){
        cout << "Error when opening " << filename << endl;
        return 2;    
    }
    fseek(fp, 0L, SEEK_END);
    sz = ftell(fp);
    cout << "Split file " << filename << "with the size " << sz << endl;    
   
    cout << "filename 's size is " << sz <<endl;
    if (fclose(fp) != 0 ){
	    cout<< "Error when closing the file"<<endl;
    }
#endif
    
#ifdef OPEN_CPP
   // string path = "~/../eshen/cse-223b-projcet/front-end/upload_temp/"+filename;
    long begin, end;
    ifstream myfile(filename.c_str());
    begin = myfile.tellg();
    myfile.seekg(0, ios::end);
    end = myfile.tellg();
    sz = end-begin;   
    myfile.close();
    cout << "Opening file " << filename << " with the size " << sz << " " << begin << " " << end << endl;
#endif
 
    fp = fopen(filename.c_str(), "rb");
    if (fp== NULL) {
	    cout<< "Error when opening the file"<<endl;
    }

    int sum = 0;
    for ( std::vector<int>::iterator it = chunk_size.begin();
	  it != chunk_size.end(); 
	  ++it ){
        sum += *it;
    }

    std::vector<int> f_offset;
    int tmp = 0;
    for ( std::vector<int>::iterator it = chunk_size.begin();
	  it != chunk_size.end();
	  ++it ){
    	std::cout << "*it " << *it <<"   sz = "<<sz<< std::endl;
	    cout<< (( double ) (*it)) / sum<<endl;
	    std::cout << "$ " <<  ((( double ) (*it)) / sum)*sz << std::endl; 
	    *it = floor( ((( double ) (*it)) / sum)*sz);
	    std::cout << "# "<< *it << std::endl;
	    tmp = tmp + (*it);
	    if (it == chunk_size.end()-1){
	        tmp = tmp - (*it);
	        *it = sz - f_offset.back();
	        tmp = tmp + (*it);   
	    }
        f_offset.push_back(tmp);
    }

#ifdef DEBUG
    std::cout<< "Here, the last item of chunk size:  "<< tmp << std::endl;
#endif
    // Get the size of external cloud storage  Dropbox0, Dropbox1, SkyDrive0
    int extCloudSize = getExtSize(username);
    cout << username << " has " << extCloudSize << "cloud accounts " << endl;


    ptree pt;
           
    int i = 0; 
    for ( std::vector<int>::iterator it = chunk_size.begin(); 
	  it != chunk_size.end();
	  ++it){
	    long fl;
	    void *ftemp = malloc( (unsigned) (*it));
	    std::cout << "chunk_size " << *it << std::endl;
	    fl = fread(ftemp, 1, *it , fp);

#ifdef DEBUG
	    std::cout << "fl " << fl << std::endl;
	    cout<<"creating a file "<<splitfn<<endl;
#endif 

        if ( fl > 0 ){
            getSegmentName(splitfn,username);
            cout << "@GetSegmentName " << splitfn << endl;
            
            op = fopen(("./upload/" + splitfn).c_str(),"wb");
 
            if(op == NULL){
                cout<< " cannot open output "<<splitfn<<endl;
                return 2;
                continue;
            }
            
            fwrite(ftemp, 1, (int) fl, op);
#ifdef DEBUG
            std::cout << " try to write " << part <<" with "<< fl << std::endl;
            std::cout << " write " << part << std::endl;
#endif
            part++;
            fclose(op);
            free(ftemp);

            // Test
           
            std::string key = username + "_" + filename;
            std::string value = splitfn;
#ifdef DEBUG
            std::cout << "Current Segment " << splitfn << " will be uploaded to cloud " << std::endl;
#endif

            // AddToList(filename, splitfn, "0"); 
            // add <$username_$segmentName, $External ID> to the kv server
            cout << "ext size *** " << extCloudSize;
            int extid = (i++) % extCloudSize;
            //AddToList(filename, splitfn, "0");

            ptree child;
            child.put(boost::lexical_cast<string>(i), splitfn);
            pt.push_back(make_pair("", child));         
            
            // std::stringstream ssw;
            // write_json(ssw, pt);
            // AddToList(filename, ssw.str(), _clientid);

            value = boost::lexical_cast<string>(extid);
            key = username + "_" + splitfn;
            Put(key, value, "0");
            // Call the funtion to push current <$segmentName, $username, $value(external id)> to the uploading queue 
            //FileAccess fa(_storageServer, _storageServerPort);
            std::cout << username << " " << splitfn << " " << extid << endl;
            fa->Upload(username, splitfn, extid);	
#ifdef DEBUG
cout<<"Upload finish one sgt"<<endl;
#endif
             

        }
        else{ 
            free(ftemp);
            break;
        }
    }

     ptree tree;
     tree.add_child("array", pt);
     std::stringstream ssw;
     write_json(ssw, tree);

     ori_filename = username + "_" + ori_filename;
     Put(ori_filename, ssw.str(), _clientid);


    if (fp != stdin){
        fclose(fp);    
    }

    printf("It is divided into %ld part\n", part);
    return 0;
  }
#if 1
  /*
   * @Jin Wang
   * @ 
   * @return vector<int> (size is 32 default as we use SHA-256 hash algorithm)
   * @para key: "blackbox" key proposed in the paper
   * hash value is stored @output
   */

  bool getPartitionOffsets(vector<int>& offsets, const std::string& key){
        
        CryptoPP::SHA256 hash;
        byte digest[CryptoPP::SHA256::DIGESTSIZE];
        
        hash.CalculateDigest(digest, (byte* const)key.c_str(), key.length());
        CryptoPP::HexEncoder encoder;
        std::string output;
        encoder.Attach(new CryptoPP::StringSink(output));
        encoder.Put(digest, sizeof(digest)) ;
        encoder.MessageEnd();
        
        std::cout << "Key is " << key << std::endl;
        std::cout << "SHA256 " << output << std::endl;

        int digestLen = output.length();
        for (int i=0; i<digestLen; ++i){
            int d = 0;
            char c1 = output[i];
           // std::cout << c1 << " ";
            if (c1 > '9')
                d += (int)(c1 - 'A') + 10;
            else
                d += (int)(c1 - '0');
                
            ++i;
            char c2 = output[i];
            //std::cout << c2 << " ";
            if (c2 > '9')
                d += (int)(c2 - 'A') + 10;
            else
                d += (int)(c2 - '0');
            offsets.push_back(d);
            std::cout << d << ":";        
        }
        std::cout << std::endl;
        return true;               
      }

  /*
   * @Jin Wang
   * @param "index" is the index for the input segment
   */
  bool getSegmentName(std::string& segName, const std::string& username){
        
        segName = "";
        int iSecret;
        //srand(time(NULL));
        iSecret = (rand() % 1000000)*1000000 + 1;
       // std::string key = username + boost::lexical_cast<string>(iSecret);

        uint64_t t;
        __asm volatile ("rdtsc" : "=A"(t));
        string key = boost::lexical_cast<string>(t);
#ifdef DEBUG
	cout <<"@getSegmentname "<<key<<endl;
#endif
        CryptoPP::SHA256 hash;
        byte digest[CryptoPP::SHA256::DIGESTSIZE];
        hash.CalculateDigest(digest, (byte* const)key.c_str(), key.length());
        CryptoPP::HexEncoder encoder;

        encoder.Attach(new CryptoPP::StringSink(segName));
        encoder.Put(digest, sizeof(digest)) ;
        encoder.MessageEnd();
	
	   //segName += key;
        segName += ".sgt";
        
        std::cout << "Seg Name is " << segName << std::endl;
        
        return true;
  }

  KVStoreStatus::type AddToList(std::string key, std::string value, std::string clientid){
    boost::shared_ptr<TSocket> socket(new TSocket(_storageServer, _storageServerPort));
    boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
    boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
    KeyValueStoreClient kv_client(protocol);
    KVStoreStatus::type st;
    transport->open();
    st = kv_client.AddToList(key, value, clientid);
    transport->close();
    return st;  
  }
  
   KVStoreStatus::type RemoveFromList(std::string key, std::string value, std::string clientid){
    boost::shared_ptr<TSocket> socket(new TSocket(_storageServer, _storageServerPort));
    boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
    boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
    KeyValueStoreClient kv_client(protocol);
    KVStoreStatus::type st;
    transport->open();
    st = kv_client.RemoveFromList(key, value, clientid);
    transport->close();
    return st;  
  }
  
  KeyValueStore::GetListResponse GetList(std::string key){
    KeyValueStore::GetListResponse response;
    boost::shared_ptr<TSocket> socket(new TSocket(_storageServer, _storageServerPort));
    boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
    boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
    KeyValueStoreClient kv_client(protocol);
    transport->open();
    kv_client.GetList(response, key);
    transport->close();
    return response;  
  }

  KeyValueStore::GetResponse Get(std::string key){
    KeyValueStore::GetResponse response;
    boost::shared_ptr<TSocket> socket(new TSocket(_storageServer, _storageServerPort));
    boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
    boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
    KeyValueStoreClient kv_client(protocol);
    transport->open();
    kv_client.Get(response, key);
    transport->close();
    return response;  
  }

  KVStoreStatus::type Put(std::string key, std::string value, std::string clientid){
    boost::shared_ptr<TSocket> socket(new TSocket(_storageServer, _storageServerPort));
    boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
    boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
    KeyValueStoreClient kv_client(protocol);
    KVStoreStatus::type st;
    transport->open();
    st = kv_client.Put(key, value, clientid);
    transport->close();
    return st;  
  }

  
  private:
   
    FileAccess *fa;
    
    std::string _storageServer;
    int _storageServerPort;
    Concurrent_Queue<string> uploadQueue;
  
   std::string _clientid;
#endif
};

int main(int argc, char **argv) {

#if 0
  vector<int> size;
  TrustedBridgeHandler *h = new TrustedBridgeHandler();
  h->getPartitionOffsets(size, "UCSD");
  std::cout << "Over" << std::endl;
  std::ifstream in("./Makefile.cpy", std::ifstream::in | std::ifstream::binary);
  in.seekg(0, std::ifstream::end);
  int length = in.tellg();
  std::cout << in.tellg();

  h->split_func("./Makefile.cpy", size, "jin");

  char* buffer = new char[length];
  in.read(buffer, length);
  std::string fn="";
  h->getSegmentName(fn, "jin");
  delete[] buffer;
  
#endif
#if 1
  if (argc != 4){
    cerr << "Usage: " << argv[0] << "<storageServerIP> <storageServerPort> <trustedBridgePort>" << endl;
    exit(0);    
  }
  std::string storageServer = std::string(argv[1]);
  int storageServerPort = atoi(argv[2]);
  int tbPort = atoi(argv[3]);

  TrustedBridgeHandler t(storageServer, storageServerPort);

#define THREAD_FAIL
#ifdef THREAD_C
    const int NUM_UPLOAD_THREADS = 3;
    pthread_t threads[NUM_UPLOAD_THREADS];;
    for (int i = 0; i < NUM_UPLOAD_THREADS; ++i){ 
        cout << "Creating thread " << i << endl;
        int rc = pthread_create(&threads[i], NULL, &TrustedBridgeHandler::checkUploadQueue, &t);
        if (rc){
            cout << "Error in Creating thread" << i << endl;
            exit(-1);    
        }    
    }
#endif

#ifdef THREAD_CPP
    const int NUM_UPLOAD_THREADS = 3;
    //pthread_t threads[NUM_UPLOAD_THREADS];
    for (int i = 0; i < NUM_UPLOAD_THREADS; ++i){
        cout << " main : waiting for thread" << endl;
        //boost::thread workerThread( boost::bind(&TrustedBridgeHandler::checkUploadQueue, &t));
        //workerThread.join();
        std::thread worker(&TrustedBridgeHandler::checkUploadQueue, &t);
        worker.join();
        cout << "Thread " << i << "done" << endl;    
    }
#endif
  //shared_ptr<TrustedBridgeHandler> handler(new TrustedBridgeHandler(storageServer, storageServerPort));
  shared_ptr<TrustedBridgeHandler> handler(&t);
  shared_ptr<TProcessor> processor(new TrustedBridgeProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(tbPort));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
#endif

#if 0 
  vector<int> size;
  TrustedBridgeHandler *h = new TrustedBridgeHandler();
  h->getPartitionOffsets(size, "UCSD");
  std::cout << "Over" << std::endl;
  std::ifstream in("./Makefile.cpy", std::ifstream::in | std::ifstream::binary);
  in.seekg(0, std::ifstream::end);
  int length = in.tellg();
  std::cout << in.tellg();

  h->split_func("./Makefile.cpy", size, "jin");

  char* buffer = new char[length];
  in.read(buffer, length);
  std::string fn="";
  h->getSegmentName(fn, "jin");
  delete[] buffer;
  
#endif
 return 0;
}

