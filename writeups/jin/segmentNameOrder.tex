%\subsubsection{Segment Name and Ordering}

As each file can be partitioned into 32 segments or more, to make segment name unique comes to be a problem. Because we do not want any file to be overwritten. 
The other question is to maintain the generating ordering of segments, which is used to assemble the file. Any small mistake here will results in failing in recovering the original file. For the first question, two conditions shall meet: first one is segment name shall be unique, sencond is that the name shall be random. SHA2-256 provide sufficient functionality that different input always gives out different hash value, which can satisfy our first condition. For the second one, we at the beginning adopt the method to give a random number among a pretty large range. After several experiments on random number generating, due to the bad distributuion of random number, some number will be generated the same in the second time. Then we change the strategy to take the system CPU counter as the input that always is unique as the seed of hash function. In this way, we first get the system CPU counter and get the corresponding unique hash value, later this will act as the name of segment.

Segment Ordering provides the mapping structure when assembling the file. This requires a stable data structure or some other kinds of format maintaing the segment generating order. Each time we get a new segment, a new item as talked above is enqueued to the uploading task queue with counter for this queue. As soon as the item successfully gets into it, a key$-$value pair $<$segment name, counter$>$ (segment with counter i means it is the i-th part of the file). Till finish partitioning file into segments, we collect all of these pairs as json array into the json object whose key is the name of the file. When trusted bridege server want resemble file, it is straigtforwatd to get the order of segment by parsing the json object by given the file name.
