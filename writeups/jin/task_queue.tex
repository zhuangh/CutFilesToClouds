
As each file would be partitioned into 32 or more segments and then they shall be pushed to external kinds of cloud storage servers, we take this way to loosely separate these two kinds of work. The main thread of trusted bridege server still take the responsibility for generating the segments. The reason why we just use one thread here is to decrease the possibility of erronously partitioning the file. Consider that several threads are working for generating new segments, shared lock for the file need be maintained for synchronizing reading the file. This will lead to a high overhead. What's worse is when a thread crashed, the segment it's responsible for will be abnorammly generated or some other kinds of errors may happen. If so, it will violates the most imporant part for trusted bridge server, what is to store complete information about the file and related segments. While, the independent segments generated by trusted bridege server can be severd with sveral threads. 
When initializing the trusted bridge server, there threads are created for dealing with the segment uploading task. A one\-writerr\-more\-reader task uploading queue will be created as the working pool for trusted bridge server. This queue maintains one mutex and one condition variiable for threads sharing. When going into "enque" opeartion, the thread need first acquire the mutex for this queue, if it's permitted, one new entry that contains the pair <username, segment name, cloud id to store current segment> is pushed back to the queue, meanwhile, \"notify\-to\-one\" for the condition variable is called to wake the thread waiting for new segment. If this queue is full, resize opeartion will be invoked. For "deque" operation, the mutex still need be checked firstly. Simiarly, it gets the access if allowed and then check segment ready for being uploaded. If there exists one, the item records the uploading specification will be removed from the queue and be transfereed to uploadToServer function. 
